import 'dart:convert';
import 'dart:io';

import 'package:crypto/crypto.dart';
import 'package:csv/csv.dart';
import 'package:dynamic_parallel_queue/dynamic_parallel_queue.dart';

import './bin/ui.dart';
import 'bin/caches.dart';
import 'bin/deepl_translator.dart';

const input = './bin/ui.dart';
const output = './lib/ui.dart';

final queue = Queue(parallel: 8);

late Map<String, String> caches;

void main(List<String> args) async {
  caches = await readCaches();
  print('缓存词条数量 ${caches.length}');
  await DeepLTranslator.init();
  final text = StringBuffer();
  text.writeln('///');
  text.writeln('/// This file is automatically generated by translate.dart');
  text.writeln('///');
  text.writeln('import "package:get/get.dart";');
  text.writeln('class UI implements Translations {');

  /// 制作静态变量
  final keys = zh.keys;
  for (var key in keys) {
    text.writeln('  static const ${key.replaceAll(' ', '')} = \'$key\';');
  }

  /// 翻译各国语言名词列表
  {
    /// 预先排序
    final languages = <String, String>{
      'en': '',
      'zh': '',
      'ja': '',
      'ko': '',
      'id': '',
      'es': '',
      'fr': '',
      'ru': '',
    };

    /// 这些语言DeepL不支持
    final skips = ['hr', 'ar', 'no', 'is', 'ga'];

    /// 翻译语言本身的名称
    final keys = DeepLTranslator.targetLanguages.keys.toList();
    for (var language in keys) {
      final key = DeepLTranslator.targetLanguages[language]!;
      if (skips.contains(key)) continue;
      if (key == 'en') {
        languages['en'] = 'English';
      } else {
        queue.add(() async {
          final translator = DeepLTranslator();
          await translator.setLanguage('en', key);
          final txt = await translator.translate(language);
          print('$language => $txt');
          caches[language] = languages[key] = txt;
          await translator.close();
        });
      }
    }
    if (queue.pending + queue.processing > 0) await queue.whenComplete();
    text.writeln(
        '  static const languages = ${JsonEncoder.withIndent('  ').convert(languages)};');
  }
  await writeCaches();
  print('完成 翻译语言名词');
  final allLanguages = DeepLTranslator.targetLanguages.keys.toList();
  final languages = {'zh': zh};

  for (var key in allLanguages) {
    final targetLanguage = DeepLTranslator.targetLanguages[key]!;
    if (targetLanguage == 'zh') continue;
    queue.add(() async {
      languages[targetLanguage] = await _translate('zh', targetLanguage, zh);
    });
  }
  await queue.whenComplete();
  text.writeln('@override');
  text.writeln(
      '  Map<String, Map<String, String>> get keys => ${JsonEncoder.withIndent('  ').convert(languages)};');

  text.writeln('}');
  await File(output).writeAsString(text.toString());
  await writeCaches();

  /// Create a csv file to preview the translate quality
  final csvConverter = ListToCsvConverter();
  final csvData = <List<String>>[];
  final keyIndex = zh.keys.toList();
  csvData.add(['key']);
  languages.forEach((language, value) {
    csvData.first.add(language);
    value.forEach((key, value) {
      final index = keyIndex.indexOf(key) + 1;
      if (language == 'zh') {
        csvData.add([key, value]);
      } else {
        csvData[index].add(value);
      }
    });
  });
  File('ui.csv').writeAsStringSync(csvConverter.convert(csvData));
  exit(0);
}

Future<Map<String, String>> _translate(String sourceLanguage,
    String targetLanguage, Map<String, String> source) async {
  final translator = DeepLTranslator();
  await translator.setLanguage(sourceLanguage, targetLanguage);
  final map = Map<String, String>.from(source);
  for (var key in source.keys) {
    final text = map[key]!, md5 = toMD5('$targetLanguage-$text');
    // print('$text $md5');
    if (key == 'findUp') {
      map[key] = 'Find Up!';
    } else if (fix[targetLanguage]?[key] != null) {
      map[key] = fix[targetLanguage]![key]!;
    } else if (caches.containsKey(md5)) {
      map[key] = caches[md5]!;
    } else {
      try {
        final hasBracket = text.contains('(');
        if (text.trim().isNotEmpty) {
          caches[md5] = map[key] = await translator.translate(text);
          await Future.delayed(Duration(milliseconds: 200));
        }
        if (!hasBracket && map[key]!.contains('(')) {
          caches[md5] = map[key] = map[key]!
              .replaceAll(RegExp(r'\(.+?\)'), '')
              .replaceAll(RegExp(r' {2,}'), ' ')
              .trim();
        }
      } catch (e) {
        print('翻译$targetLanguage $key时错误：$e');
        await translator.close();
        return _translate(sourceLanguage, targetLanguage, source);
      }
    }
  }
  await writeCaches();
  print('完成翻译 $targetLanguage');

  await translator.close();
  return map;
}

String toMD5(String input) => md5.convert(utf8.encode(input)).toString();
